<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Runtime Web Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .section h2 {
            color: #333;
            margin-top: 0;
        }
        .provider-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .provider-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .provider-card h3 {
            margin: 0 0 10px 0;
            color: #007bff;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .model-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .model-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .model-card h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }
        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: vertical;
        }
        .response-area {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .extension-status {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ONNX Runtime Web Test</h1>
        <p>This page demonstrates the ONNX Runtime Web integration with provider priority: WebNN (NPU/GPU) → WebGPU → WASM</p>

        <div id="extensionStatus" class="extension-status" style="display: none;">
            <!-- Extension status will be shown here -->
        </div>

        <div class="section">
            <h2>Provider Information</h2>
            <div id="providerInfo" class="provider-info">
                <div class="provider-card">
                    <h3>WebNN</h3>
                    <p>Status: <span id="webnnStatus">Checking...</span></p>
                    <p>Preferred Device: <span id="webnnDevice">-</span></p>
                    <p>Available Devices: <span id="webnnDevices">-</span></p>
                </div>
                <div class="provider-card">
                    <h3>WebGPU</h3>
                    <p>Status: <span id="webgpuStatus">Checking...</span></p>
                    <p>Adapter: <span id="webgpuAdapter">-</span></p>
                </div>
                <div class="provider-card">
                    <h3>WASM</h3>
                    <p>Status: <span id="wasmStatus">Checking...</span></p>
                    <p>Threads: <span id="wasmThreads">-</span></p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Available Models</h2>
            <div id="modelList" class="model-list">
                <!-- Models will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2>Model Testing</h2>
            <div>
                <label for="modelSelect">Select Model:</label>
                <select id="modelSelect">
                    <option value="">Choose a model...</option>
                </select>
                <button id="loadModelBtn">Load Model</button>
                <button id="unloadModelBtn">Unload Model</button>
                <label>
                    <input type="checkbox" id="useWorkerCheck"> Use Web Worker
                </label>
            </div>
            <div id="modelStatus" class="status info" style="display: none;">
                <!-- Model status will be shown here -->
            </div>
        </div>

        <div class="section">
            <h2>Inference Test</h2>
            <div>
                <label for="testInput">Input Message:</label>
                <textarea id="testInput" placeholder="Enter your message here...">Hello, how are you today?</textarea>
                <button id="generateBtn">Generate Response</button>
            </div>
            <div id="responseArea" class="response-area" style="display: none;">
                <!-- Response will be shown here -->
            </div>
        </div>

        <div class="section">
            <h2>Cache Management</h2>
            <div>
                <button id="getCacheStatsBtn">Get Cache Stats</button>
                <button id="getCachedModelsBtn">Get Cached Models</button>
                <button id="clearAllCacheBtn">Clear All Cache</button>
                <button id="cleanupOldCacheBtn">Cleanup Old Models</button>
            </div>
            <div id="cacheInfo" class="status info" style="display: none;">
                <!-- Cache info will be shown here -->
            </div>
        </div>

        <div class="section">
            <h2>System Information</h2>
            <div id="systemInfo">
                <!-- System info will be loaded here -->
            </div>
        </div>
    </div>

    <script type="module">
        class ONNXTestPage {
            constructor() {
                this.initializeUI()
                this.checkExtensionAvailability()
                this.checkProviders()
                this.loadSystemInfo()
            }

            async checkExtensionAvailability() {
                const statusDiv = document.getElementById('extensionStatus')
                
                try {
                    // Check if extension is available
                    const response = await this.sendMessage('get-available-models')
                    if (response.success) {
                        statusDiv.style.display = 'block'
                        statusDiv.innerHTML = `
                            <strong>✅ Extension Available</strong><br>
                            LLM Control Panel extension is loaded and ready to use.
                        `
                        statusDiv.className = 'extension-status'
                        statusDiv.style.backgroundColor = '#d4edda'
                        statusDiv.style.color = '#155724'
                        statusDiv.style.borderColor = '#c3e6cb'
                        
                        // Load models after extension is confirmed available
                        this.updateModelList()
                    } else {
                        throw new Error('Extension not responding')
                    }
                } catch (error) {
                    statusDiv.style.display = 'block'
                    statusDiv.innerHTML = `
                        <strong>❌ Extension Not Available</strong><br>
                        Please install and enable the LLM Control Panel extension to use this test page.
                    `
                    statusDiv.className = 'extension-status'
                    statusDiv.style.backgroundColor = '#f8d7da'
                    statusDiv.style.color = '#721c24'
                    statusDiv.style.borderColor = '#f5c6cb'
                }
            }

            async sendMessage(type, data = {}) {
                return new Promise((resolve, reject) => {
                    try {
                        chrome.runtime.sendMessage({ type, ...data }, (response) => {
                            if (chrome.runtime.lastError) {
                                reject(new Error(chrome.runtime.lastError.message))
                            } else {
                                resolve(response)
                            }
                        })
                    } catch (error) {
                        reject(error)
                    }
                })
            }

            initializeUI() {
                // Set up event listeners
                document.getElementById('loadModelBtn').addEventListener('click', () => this.loadModel())
                document.getElementById('unloadModelBtn').addEventListener('click', () => this.unloadModel())
                document.getElementById('generateBtn').addEventListener('click', () => this.generateResponse())
                
                // Cache management event listeners
                document.getElementById('getCacheStatsBtn').addEventListener('click', () => this.getCacheStats())
                document.getElementById('getCachedModelsBtn').addEventListener('click', () => this.getCachedModels())
                document.getElementById('clearAllCacheBtn').addEventListener('click', () => this.clearAllCache())
                document.getElementById('cleanupOldCacheBtn').addEventListener('click', () => this.cleanupOldCache())
            }

            async checkProviders() {
                try {
                    // Get available providers from extension
                    const providersResponse = await this.sendMessage('get-available-providers')
                    const providers = providersResponse.success ? providersResponse.providers : []
                    
                    // Check WebNN availability
                    const webnnStatus = document.getElementById('webnnStatus')
                    const webnnDevice = document.getElementById('webnnDevice')
                    const webnnDevices = document.getElementById('webnnDevices')

                    if (providers.includes('webnn')) {
                        webnnStatus.textContent = 'Available'
                        webnnStatus.style.color = 'green'
                        
                        try {
                            const devicesResponse = await this.sendMessage('get-webnn-devices')
                            const devices = devicesResponse.success ? devicesResponse.devices : []
                            webnnDevices.textContent = devices.length > 0 ? devices.map(d => d.name).join(', ') : 'None detected'
                            
                            const preferredResponse = await this.sendMessage('get-preferred-webnn-device')
                            const preferredDevice = preferredResponse.success ? preferredResponse.device : null
                            webnnDevice.textContent = preferredDevice ? `${preferredDevice.name} (${preferredDevice.type})` : 'None'
                        } catch (error) {
                            webnnDevices.textContent = 'Error detecting devices'
                            webnnDevice.textContent = 'Error'
                        }
                    } else {
                        webnnStatus.textContent = 'Not Available'
                        webnnStatus.style.color = 'red'
                    }

                    // Check WebGPU availability
                    const webgpuStatus = document.getElementById('webgpuStatus')
                    const webgpuAdapter = document.getElementById('webgpuAdapter')

                    if (providers.includes('webgpu')) {
                        webgpuStatus.textContent = 'Available'
                        webgpuStatus.style.color = 'green'
                        
                        if (navigator.gpu) {
                            try {
                                const adapter = await navigator.gpu.requestAdapter()
                                webgpuAdapter.textContent = adapter ? (adapter.name || 'Unknown GPU') : 'No compatible GPU'
                            } catch (error) {
                                webgpuAdapter.textContent = 'Error detecting GPU'
                            }
                        } else {
                            webgpuAdapter.textContent = 'WebGPU not supported'
                        }
                    } else {
                        webgpuStatus.textContent = 'Not Available'
                        webgpuStatus.style.color = 'red'
                    }

                    // Check WASM availability
                    const wasmStatus = document.getElementById('wasmStatus')
                    const wasmThreads = document.getElementById('wasmThreads')

                    if (providers.includes('wasm')) {
                        wasmStatus.textContent = 'Available'
                        wasmStatus.style.color = 'green'
                        wasmThreads.textContent = navigator.hardwareConcurrency || 'Unknown'
                    } else {
                        wasmStatus.textContent = 'Not Available'
                        wasmStatus.style.color = 'red'
                    }
                } catch (error) {
                    console.error('Error checking providers:', error)
                    this.showStatus('Error checking providers: ' + error.message, 'error')
                }
            }

            async updateModelList() {
                try {
                    const response = await this.sendMessage('get-available-models')
                    if (!response.success) {
                        throw new Error(response.error || 'Failed to get models')
                    }

                    const models = response.models
                    const modelList = document.getElementById('modelList')
                    modelList.innerHTML = ''

                    models.forEach(model => {
                        const card = document.createElement('div')
                        card.className = 'model-card'
                        card.innerHTML = `
                            <h4>${model.name}</h4>
                            <p>${model.description}</p>
                            <p><strong>ID:</strong> ${model.id}</p>
                            <button onclick="window.testPage.loadSpecificModel('${model.id}')">Load</button>
                        `
                        modelList.appendChild(card)
                    })

                    // Update select dropdown
                    const select = document.getElementById('modelSelect')
                    select.innerHTML = '<option value="">Choose a model...</option>'
                    models.forEach(model => {
                        const option = document.createElement('option')
                        option.value = model.id
                        option.textContent = model.name
                        select.appendChild(option)
                    })
                } catch (error) {
                    console.error('Error loading models:', error)
                    this.showStatus('Error loading models: ' + error.message, 'error')
                }
            }

            async loadModel() {
                const modelId = document.getElementById('modelSelect').value
                if (!modelId) {
                    this.showStatus('Please select a model first', 'error')
                    return
                }

                const useWorker = document.getElementById('useWorkerCheck').checked
                this.showStatus(`Loading model: ${modelId}...`, 'info')
                
                try {
                    const response = await this.sendMessage('load-model', { modelId, useWorker })
                    if (response.success) {
                        this.showStatus(`Model ${modelId} loaded successfully!`, 'success')
                    } else {
                        this.showStatus(`Failed to load model: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error loading model: ${error.message}`, 'error')
                }
            }

            async loadSpecificModel(modelId) {
                const useWorker = document.getElementById('useWorkerCheck').checked
                this.showStatus(`Loading model: ${modelId}...`, 'info')
                
                try {
                    const response = await this.sendMessage('load-model', { modelId, useWorker })
                    if (response.success) {
                        this.showStatus(`Model ${modelId} loaded successfully!`, 'success')
                    } else {
                        this.showStatus(`Failed to load model: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error loading model: ${error.message}`, 'error')
                }
            }

            async unloadModel() {
                const modelId = document.getElementById('modelSelect').value
                if (!modelId) {
                    this.showStatus('Please select a model first', 'error')
                    return
                }

                const useWorker = document.getElementById('useWorkerCheck').checked
                this.showStatus(`Unloading model: ${modelId}...`, 'info')
                
                try {
                    const response = await this.sendMessage('unload-model', { modelId, useWorker })
                    if (response.success) {
                        this.showStatus(`Model ${modelId} unloaded successfully!`, 'success')
                    } else {
                        this.showStatus(`Failed to unload model: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error unloading model: ${error.message}`, 'error')
                }
            }

            async generateResponse() {
                const input = document.getElementById('testInput').value
                if (!input.trim()) {
                    this.showStatus('Please enter a message', 'error')
                    return
                }

                const modelId = document.getElementById('modelSelect').value
                if (!modelId) {
                    this.showStatus('Please select a model first', 'error')
                    return
                }

                this.showStatus('Generating response...', 'info')
                
                try {
                    const response = await this.sendMessage('generate-response', { prompt: input, modelId })
                    if (response.success) {
                        const responseArea = document.getElementById('responseArea')
                        responseArea.style.display = 'block'
                        responseArea.textContent = response.response
                        this.showStatus('Response generated successfully!', 'success')
                    } else {
                        this.showStatus(`Failed to generate response: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error generating response: ${error.message}`, 'error')
                }
            }

            showStatus(message, type) {
                const statusDiv = document.getElementById('modelStatus')
                statusDiv.style.display = 'block'
                statusDiv.className = `status ${type}`
                statusDiv.textContent = message
            }

            loadSystemInfo() {
                const systemInfo = document.getElementById('systemInfo')
                systemInfo.innerHTML = `
                    <p><strong>User Agent:</strong> ${navigator.userAgent}</p>
                    <p><strong>Platform:</strong> ${navigator.platform}</p>
                    <p><strong>Hardware Concurrency:</strong> ${navigator.hardwareConcurrency || 'Unknown'}</p>
                    <p><strong>Memory:</strong> ${performance.memory ? `${Math.round(performance.memory.usedJSHeapSize / 1024 / 1024)}MB / ${Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)}MB` : 'Unknown'}</p>
                    <p><strong>WebNN Available:</strong> ${typeof navigator.ml !== 'undefined' ? 'Yes' : 'No'}</p>
                    <p><strong>WebGPU Available:</strong> ${typeof navigator.gpu !== 'undefined' ? 'Yes' : 'No'}</p>
                    <p><strong>WebAssembly Available:</strong> ${typeof WebAssembly !== 'undefined' ? 'Yes' : 'No'}</p>
                `
            }

            // Cache management methods
            async getCacheStats() {
                this.showStatus('Getting cache stats...', 'info')
                
                try {
                    const response = await this.sendMessage('get-cache-stats')
                    if (response.success) {
                        const stats = response.stats
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cache Statistics</h3>
                            <p><strong>Total Size:</strong> ${this.formatBytes(stats.totalSize || 0)}</p>
                            <p><strong>Model Count:</strong> ${stats.modelCount || 0}</p>
                            <p><strong>Available Space:</strong> ${this.formatBytes(stats.availableSpace || 0)}</p>
                            <p><strong>Usage:</strong> ${Math.round(((stats.totalSize || 0) / (5 * 1024 * 1024)) * 100)}%</p>
                        `
                    } else {
                        this.showStatus(`Failed to get cache stats: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error getting cache stats: ${error.message}`, 'error')
                }
            }

            async getCachedModels() {
                this.showStatus('Getting cached models...', 'info')
                
                try {
                    const response = await this.sendMessage('get-cached-models')
                    if (response.success) {
                        const models = response.models || []
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cached Models</h3>
                            ${models.length > 0 ? models.map(model => `
                                <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                                    <p><strong>${model.name || model.id}</strong></p>
                                    <p>Size: ${this.formatBytes(model.size || 0)}</p>
                                    <p>Provider: ${model.provider || 'Unknown'}</p>
                                    <p>Cached: ${model.timestamp ? new Date(model.timestamp).toLocaleString() : 'Unknown'}</p>
                                </div>
                            `).join('') : '<p>No cached models found.</p>'}
                        `
                    } else {
                        this.showStatus(`Failed to get cached models: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error getting cached models: ${error.message}`, 'error')
                }
            }

            async clearAllCache() {
                this.showStatus('Clearing all cache...', 'info')
                
                try {
                    const response = await this.sendMessage('clear-all-cached-models')
                    if (response.success) {
                        this.showStatus('All cached models cleared successfully!', 'success')
                        
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cache Cleared</h3>
                            <p>All cached models have been removed.</p>
                        `
                    } else {
                        this.showStatus(`Failed to clear cache: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error clearing cache: ${error.message}`, 'error')
                }
            }

            async cleanupOldCache() {
                this.showStatus('Cleaning up old models...', 'info')
                
                try {
                    const response = await this.sendMessage('cleanup-old-cached-models', { maxAge: 7 * 24 * 60 * 60 * 1000 }) // 7 days
                    if (response.success) {
                        this.showStatus(`Old models cleaned up successfully! Removed ${response.removedCount || 0} models.`, 'success')
                        
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cleanup Complete</h3>
                            <p>Old cached models have been removed. Removed ${response.removedCount || 0} models.</p>
                        `
                    } else {
                        this.showStatus(`Failed to cleanup old models: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error cleaning up old models: ${error.message}`, 'error')
                }
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes'
                
                const k = 1024
                const sizes = ['Bytes', 'KB', 'MB', 'GB']
                const i = Math.floor(Math.log(bytes) / Math.log(k))
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
            }
        }

        // Initialize the test page
        window.testPage = new ONNXTestPage()
    </script>
</body>
</html> 