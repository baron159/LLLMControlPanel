<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Runtime Web Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .section h2 {
            color: #333;
            margin-top: 0;
        }
        .provider-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .provider-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .provider-card h3 {
            margin: 0 0 10px 0;
            color: #007bff;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .model-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .model-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .model-card h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }
        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: vertical;
        }
        .response-area {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .extension-status {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ONNX Runtime Web Test</h1>
        <p>This page demonstrates the ONNX Runtime Web integration with provider priority: WebNN (NPU/GPU) → WebGPU → WASM</p>

        <div id="extensionStatus" class="extension-status" style="display: none;">
            <!-- Extension status will be shown here -->
        </div>

        <div class="section">
            <h2>Provider Information</h2>
            <div id="providerInfo" class="provider-info">
                <div class="provider-card">
                    <h3>WebNN</h3>
                    <p>Status: <span id="webnnStatus">Checking...</span></p>
                    <p>Preferred Device: <span id="webnnDevice">-</span></p>
                    <p>Available Devices: <span id="webnnDevices">-</span></p>
                    <p>Device Count: <span id="webnnDeviceCount">-</span></p>
                    <button id="refreshWebNNBtn" style="margin-top: 10px;">Refresh WebNN Devices</button>
                </div>
                <div class="provider-card">
                    <h3>WebGPU</h3>
                    <p>Status: <span id="webgpuStatus">Checking...</span></p>
                    <p>Adapter: <span id="webgpuAdapter">-</span></p>
                </div>
                <div class="provider-card">
                    <h3>WASM</h3>
                    <p>Status: <span id="wasmStatus">Checking...</span></p>
                    <p>Threads: <span id="wasmThreads">-</span></p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Detailed Device Information</h2>
            <div id="deviceDetails" class="provider-info">
                <!-- Detailed device information will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2>Available Models</h2>
            <div id="modelList" class="model-list">
                <!-- Models will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2>Model Testing</h2>
            <div>
                <label for="modelSelect">Select Model:</label>
                <select id="modelSelect">
                    <option value="">Choose a model...</option>
                </select>
                <button id="loadModelBtn">Load Model</button>
                <button id="unloadModelBtn">Unload Model</button>
                <label>
                    <input type="checkbox" id="useWorkerCheck"> Use Web Worker
                </label>
            </div>
            <div id="modelStatus" class="status info" style="display: none;">
                <!-- Model status will be shown here -->
            </div>
        </div>

        <div class="section">
            <h2>Inference Test</h2>
            <div>
                <label for="testInput">Input Message:</label>
                <textarea id="testInput" placeholder="Enter your message here...">Hello, how are you today?</textarea>
                <button id="generateBtn">Generate Response</button>
            </div>
            <div id="responseArea" class="response-area" style="display: none;">
                <!-- Response will be shown here -->
            </div>
        </div>

        <div class="section">
            <h2>Cache Management</h2>
            <div>
                <button id="getCacheStatsBtn">Get Cache Stats</button>
                <button id="getCachedModelsBtn">Get Cached Models</button>
                <button id="clearAllCacheBtn">Clear All Cache</button>
                <button id="cleanupOldCacheBtn">Cleanup Old Models</button>
            </div>
            <div id="cacheInfo" class="status info" style="display: none;">
                <!-- Cache info will be shown here -->
            </div>
        </div>

        <div class="section">
            <h2>System Information</h2>
            <div id="systemInfo">
                <!-- System info will be loaded here -->
            </div>
        </div>
    </div>

    <script type="module">
        class ONNXTestPage {
            constructor() {
                this.initializeUI()
                this.initializeExtension()
            }

            async initializeExtension() {
                // First check if we're in a Chrome extension context
                if (typeof chrome === 'undefined' || !chrome.runtime) {
                    this.showExtensionError('Chrome extension API not available. Please run this page in a Chrome extension context.')
                    return
                }

                // Check extension availability first
                await this.checkExtensionAvailability()
                
                // Only proceed with other checks if extension is available
                if (this.extensionAvailable) {
                    await this.checkProviders()
                    await this.updateModelList()
                }
                
                // Load system info regardless of extension status
                this.loadSystemInfo()
            }

            async checkExtensionAvailability() {
                const statusDiv = document.getElementById('extensionStatus')
                
                try {
                    // Check if extension is available using the page-level API
                    if (window.llmControlPanel) {
                        const isAvailable = await window.llmControlPanel.isAvailable()
                        if (isAvailable) {
                            this.extensionAvailable = true
                            statusDiv.style.display = 'block'
                            statusDiv.innerHTML = `
                                <strong>✅ Extension Available</strong><br>
                                LLM Control Panel extension is loaded and ready to use.
                            `
                            statusDiv.className = 'extension-status'
                            statusDiv.style.backgroundColor = '#d4edda'
                            statusDiv.style.color = '#155724'
                            statusDiv.style.borderColor = '#c3e6cb'
                        } else {
                            throw new Error('Extension not responding')
                        }
                    } else {
                        throw new Error('Extension API not available')
                    }
                } catch (error) {
                    this.extensionAvailable = false
                    statusDiv.style.display = 'block'
                    statusDiv.innerHTML = `
                        <strong>❌ Extension Not Available</strong><br>
                        Please install and enable the LLM Control Panel extension to use this test page.<br>
                        Error: ${error.message}
                    `
                    statusDiv.className = 'extension-status'
                    statusDiv.style.backgroundColor = '#f8d7da'
                    statusDiv.style.color = '#721c24'
                    statusDiv.style.borderColor = '#f5c6cb'
                }
            }

            showExtensionError(message) {
                const statusDiv = document.getElementById('extensionStatus')
                statusDiv.style.display = 'block'
                statusDiv.innerHTML = `
                    <strong>❌ Extension Error</strong><br>
                    ${message}
                `
                statusDiv.className = 'extension-status'
                statusDiv.style.backgroundColor = '#f8d7da'
                statusDiv.style.color = '#721c24'
                statusDiv.style.borderColor = '#f5c6cb'
            }

            async sendMessage(type, data = {}) {
                return new Promise((resolve, reject) => {
                    try {
                        // Check if the page-level API is available
                        if (window.llmControlPanel) {
                            // Map the old message types to new API methods
                            const apiMethodMap = {
                                'get-available-models': () => window.llmControlPanel.getAvailableModels(),
                                'get-available-providers': () => window.llmControlPanel.getAvailableProviders(),
                                'get-webnn-devices': () => window.llmControlPanel.getWebNNDevices(),
                                'get-preferred-webnn-device': () => window.llmControlPanel.getPreferredWebNNDevice(),
                                'load-model': () => window.llmControlPanel.loadModel(data.modelId, data.useWorker),
                                'unload-model': () => window.llmControlPanel.unloadModel(data.modelId, data.useWorker),
                                'generate-response': () => window.llmControlPanel.generateResponse(data.prompt, data.modelId),
                                'get-cache-stats': () => window.llmControlPanel.getCacheStats(),
                                'get-cached-models': () => window.llmControlPanel.getCachedModels(),
                                'clear-all-cached-models': () => window.llmControlPanel.clearAllCachedModels(),
                                'cleanup-old-cached-models': () => window.llmControlPanel.cleanupOldCachedModels(data.maxAge)
                            }

                            const apiMethod = apiMethodMap[type]
                            if (apiMethod) {
                                apiMethod()
                                    .then(response => {
                                        // Handle different response formats
                                        if (type === 'get-available-models') {
                                            resolve({ success: true, models: response.models })
                                        } else if (type === 'get-available-providers') {
                                            resolve({ success: true, providers: response.providers })
                                        } else if (type === 'get-webnn-devices') {
                                            resolve({ success: true, devices: response.devices })
                                        } else if (type === 'get-preferred-webnn-device') {
                                            resolve({ success: true, device: response.device })
                                        } else if (type === 'get-cache-stats') {
                                            resolve({ success: true, stats: response.stats })
                                        } else if (type === 'get-cached-models') {
                                            resolve({ success: true, models: response.models })
                                        } else if (type === 'clear-all-cached-models') {
                                            resolve({ success: true })
                                        } else if (type === 'cleanup-old-cached-models') {
                                            resolve({ success: true, removedCount: response.removedCount })
                                        } else if (type === 'load-model' || type === 'unload-model') {
                                            resolve({ success: true })
                                        } else if (type === 'generate-response') {
                                            resolve({ success: true, response: response })
                                        } else {
                                            resolve({ success: true, response: response })
                                        }
                                    })
                                    .catch(error => {
                                        resolve({ success: false, error: error.message })
                                    })
                            } else {
                                reject(new Error(`Unknown message type: ${type}`))
                            }
                        } else {
                            reject(new Error('Extension API not available'))
                        }
                    } catch (error) {
                        reject(error)
                    }
                })
            }

            initializeUI() {
                // Set up event listeners
                document.getElementById('loadModelBtn').addEventListener('click', () => this.loadModel())
                document.getElementById('unloadModelBtn').addEventListener('click', () => this.unloadModel())
                document.getElementById('generateBtn').addEventListener('click', () => this.generateResponse())
                
                // Cache management event listeners
                document.getElementById('getCacheStatsBtn').addEventListener('click', () => this.getCacheStats())
                document.getElementById('getCachedModelsBtn').addEventListener('click', () => this.getCachedModels())
                document.getElementById('clearAllCacheBtn').addEventListener('click', () => this.clearAllCache())
                document.getElementById('cleanupOldCacheBtn').addEventListener('click', () => this.cleanupOldCache())
                
                // Device testing event listeners
                document.getElementById('refreshWebNNBtn').addEventListener('click', () => this.refreshWebNNDevices())
            }

            async checkProviders() {
                try {
                    // Check if extension is available first
                    if (!this.extensionAvailable) {
                        this.showProviderFallbackInfo()
                        return
                    }

                    // Get available providers from extension
                    const providersResponse = await this.sendMessage('get-available-providers')
                    const providers = providersResponse.success ? providersResponse.providers : []
                    
                    // Check WebNN availability
                    const webnnStatus = document.getElementById('webnnStatus')
                    const webnnDevice = document.getElementById('webnnDevice')
                    const webnnDevices = document.getElementById('webnnDevices')
                    const webnnDeviceCount = document.getElementById('webnnDeviceCount')

                    if (providers.includes('webnn')) {
                        webnnStatus.textContent = 'Available'
                        webnnStatus.style.color = 'green'
                        
                        try {
                            const devicesResponse = await this.sendMessage('get-webnn-devices')
                            const devices = devicesResponse.success ? devicesResponse.devices : []
                            webnnDevices.textContent = devices.length > 0 ? devices.map(d => d.name).join(', ') : 'None detected'
                            webnnDeviceCount.textContent = devices.length
                            
                            const preferredResponse = await this.sendMessage('get-preferred-webnn-device')
                            const preferredDevice = preferredResponse.success ? preferredResponse.device : null
                            webnnDevice.textContent = preferredDevice ? `${preferredDevice.name} (${preferredDevice.type})` : 'None'
                            
                            // Load detailed device information
                            this.loadDetailedDeviceInfo(devices)
                        } catch (error) {
                            webnnDevices.textContent = 'Error detecting devices'
                            webnnDevice.textContent = 'Error'
                            webnnDeviceCount.textContent = 'Error'
                        }
                    } else {
                        webnnStatus.textContent = 'Not Available'
                        webnnStatus.style.color = 'red'
                        webnnDevices.textContent = 'N/A'
                        webnnDeviceCount.textContent = 'N/A'
                    }

                    // Check WebGPU availability
                    const webgpuStatus = document.getElementById('webgpuStatus')
                    const webgpuAdapter = document.getElementById('webgpuAdapter')

                    if (providers.includes('webgpu')) {
                        webgpuStatus.textContent = 'Available'
                        webgpuStatus.style.color = 'green'
                        
                        if (navigator.gpu) {
                            try {
                                const adapter = await navigator.gpu.requestAdapter()
                                webgpuAdapter.textContent = adapter ? (adapter.name || 'Unknown GPU') : 'No compatible GPU'
                            } catch (error) {
                                webgpuAdapter.textContent = 'Error detecting GPU'
                            }
                        } else {
                            webgpuAdapter.textContent = 'WebGPU not supported'
                        }
                    } else {
                        webgpuStatus.textContent = 'Not Available'
                        webgpuStatus.style.color = 'red'
                    }

                    // Check WASM availability
                    const wasmStatus = document.getElementById('wasmStatus')
                    const wasmThreads = document.getElementById('wasmThreads')

                    if (providers.includes('wasm')) {
                        wasmStatus.textContent = 'Available'
                        wasmStatus.style.color = 'green'
                        wasmThreads.textContent = navigator.hardwareConcurrency || 'Unknown'
                    } else {
                        wasmStatus.textContent = 'Not Available'
                        wasmStatus.style.color = 'red'
                    }
                } catch (error) {
                    console.error('Error checking providers:', error)
                    this.showProviderFallbackInfo()
                }
            }

            showProviderFallbackInfo() {
                // Show fallback information when extension is not available
                const webnnStatus = document.getElementById('webnnStatus')
                const webnnDevice = document.getElementById('webnnDevice')
                const webnnDevices = document.getElementById('webnnDevices')
                const webnnDeviceCount = document.getElementById('webnnDeviceCount')
                const webgpuStatus = document.getElementById('webgpuStatus')
                const webgpuAdapter = document.getElementById('webgpuAdapter')
                const wasmStatus = document.getElementById('wasmStatus')
                const wasmThreads = document.getElementById('wasmThreads')

                // WebNN fallback
                webnnStatus.textContent = 'Extension Required'
                webnnStatus.style.color = 'orange'
                webnnDevice.textContent = 'N/A'
                webnnDevices.textContent = 'N/A'
                webnnDeviceCount.textContent = 'N/A'

                // WebGPU fallback
                if (navigator.gpu) {
                    webgpuStatus.textContent = 'Available (Browser)'
                    webgpuStatus.style.color = 'green'
                    webgpuAdapter.textContent = 'Check browser support'
                } else {
                    webgpuStatus.textContent = 'Not Available'
                    webgpuStatus.style.color = 'red'
                    webgpuAdapter.textContent = 'WebGPU not supported'
                }

                // WASM fallback
                if (typeof WebAssembly !== 'undefined') {
                    wasmStatus.textContent = 'Available (Browser)'
                    wasmStatus.style.color = 'green'
                    wasmThreads.textContent = navigator.hardwareConcurrency || 'Unknown'
                } else {
                    wasmStatus.textContent = 'Not Available'
                    wasmStatus.style.color = 'red'
                    wasmThreads.textContent = 'N/A'
                }
            }

            async updateModelList() {
                try {
                    // Check if extension is available first
                    if (!this.extensionAvailable) {
                        const modelList = document.getElementById('modelList')
                        modelList.innerHTML = '<p>Extension required to load models</p>'
                        return
                    }

                    const response = await this.sendMessage('get-available-models')
                    if (!response.success) {
                        throw new Error(response.error || 'Failed to get models')
                    }

                    const models = response.models
                    const modelList = document.getElementById('modelList')
                    modelList.innerHTML = ''

                    models.forEach(model => {
                        const card = document.createElement('div')
                        card.className = 'model-card'
                        card.innerHTML = `
                            <h4>${model.name}</h4>
                            <p>${model.description}</p>
                            <p><strong>ID:</strong> ${model.id}</p>
                            <button onclick="window.testPage.loadSpecificModel('${model.id}')">Load</button>
                        `
                        modelList.appendChild(card)
                    })

                    // Update select dropdown
                    const select = document.getElementById('modelSelect')
                    select.innerHTML = '<option value="">Choose a model...</option>'
                    models.forEach(model => {
                        const option = document.createElement('option')
                        option.value = model.id
                        option.textContent = model.name
                        select.appendChild(option)
                    })
                } catch (error) {
                    console.error('Error loading models:', error)
                    const modelList = document.getElementById('modelList')
                    modelList.innerHTML = `<p>Error loading models: ${error.message}</p>`
                }
            }

            async loadModel() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to load models', 'error')
                    return
                }

                const modelId = document.getElementById('modelSelect').value
                if (!modelId) {
                    this.showStatus('Please select a model first', 'error')
                    return
                }

                const useWorker = document.getElementById('useWorkerCheck').checked
                this.showStatus(`Loading model: ${modelId}...`, 'info')
                
                try {
                    const response = await this.sendMessage('load-model', { modelId, useWorker })
                    if (response.success) {
                        this.showStatus(`Model ${modelId} loaded successfully!`, 'success')
                    } else {
                        this.showStatus(`Failed to load model: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error loading model: ${error.message}`, 'error')
                }
            }

            async loadSpecificModel(modelId) {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to load models', 'error')
                    return
                }

                const useWorker = document.getElementById('useWorkerCheck').checked
                this.showStatus(`Loading model: ${modelId}...`, 'info')
                
                try {
                    const response = await this.sendMessage('load-model', { modelId, useWorker })
                    if (response.success) {
                        this.showStatus(`Model ${modelId} loaded successfully!`, 'success')
                    } else {
                        this.showStatus(`Failed to load model: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error loading model: ${error.message}`, 'error')
                }
            }

            async unloadModel() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to unload models', 'error')
                    return
                }

                const modelId = document.getElementById('modelSelect').value
                if (!modelId) {
                    this.showStatus('Please select a model first', 'error')
                    return
                }

                const useWorker = document.getElementById('useWorkerCheck').checked
                this.showStatus(`Unloading model: ${modelId}...`, 'info')
                
                try {
                    const response = await this.sendMessage('unload-model', { modelId, useWorker })
                    if (response.success) {
                        this.showStatus(`Model ${modelId} unloaded successfully!`, 'success')
                    } else {
                        this.showStatus(`Failed to unload model: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error unloading model: ${error.message}`, 'error')
                }
            }

            async generateResponse() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to generate responses', 'error')
                    return
                }

                const input = document.getElementById('testInput').value
                if (!input.trim()) {
                    this.showStatus('Please enter a message', 'error')
                    return
                }

                const modelId = document.getElementById('modelSelect').value
                if (!modelId) {
                    this.showStatus('Please select a model first', 'error')
                    return
                }

                this.showStatus('Generating response...', 'info')
                
                try {
                    const response = await this.sendMessage('generate-response', { prompt: input, modelId })
                    if (response.success) {
                        const responseArea = document.getElementById('responseArea')
                        responseArea.style.display = 'block'
                        responseArea.textContent = response.response
                        this.showStatus('Response generated successfully!', 'success')
                    } else {
                        this.showStatus(`Failed to generate response: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error generating response: ${error.message}`, 'error')
                }
            }

            showStatus(message, type) {
                const statusDiv = document.getElementById('modelStatus')
                statusDiv.style.display = 'block'
                statusDiv.className = `status ${type}`
                statusDiv.textContent = message
            }

            loadSystemInfo() {
                const systemInfo = document.getElementById('systemInfo')
                
                // Enhanced system information for device detection testing
                const deviceMemory = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown'
                const connectionType = navigator.connection ? navigator.connection.effectiveType : 'Unknown'
                const batteryInfo = this.getBatteryInfo()
                const userAgentInfo = this.parseUserAgent()
                
                systemInfo.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div class="provider-card">
                            <h3>Basic System Info</h3>
                            <p><strong>User Agent:</strong> ${navigator.userAgent}</p>
                            <p><strong>Platform:</strong> ${navigator.platform}</p>
                            <p><strong>Hardware Concurrency:</strong> ${navigator.hardwareConcurrency || 'Unknown'}</p>
                            <p><strong>Device Memory:</strong> ${deviceMemory}</p>
                            <p><strong>Connection Type:</strong> ${connectionType}</p>
                            <p><strong>Battery Status:</strong> ${batteryInfo}</p>
                        </div>
                        
                        <div class="provider-card">
                            <h3>API Availability</h3>
                            <p><strong>WebNN Available:</strong> ${typeof navigator.ml !== 'undefined' ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>WebGPU Available:</strong> ${typeof navigator.gpu !== 'undefined' ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>WebAssembly Available:</strong> ${typeof WebAssembly !== 'undefined' ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>WebGL Available:</strong> ${this.isWebGLAvailable() ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>Battery API:</strong> ${'getBattery' in navigator ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>Device Memory API:</strong> ${'deviceMemory' in navigator ? '✅ Yes' : '❌ No'}</p>
                        </div>
                        
                        <div class="provider-card">
                            <h3>Device Detection Hints</h3>
                            <p><strong>Architecture:</strong> ${userAgentInfo.architecture}</p>
                            <p><strong>Platform Type:</strong> ${userAgentInfo.platformType}</p>
                            <p><strong>Mobile Device:</strong> ${userAgentInfo.isMobile ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>High Performance:</strong> ${this.isHighPerformanceDevice() ? '✅ Yes' : '❌ No'}</p>
                            <p><strong>Memory Usage:</strong> ${this.getMemoryUsage()}</p>
                        </div>
                    </div>
                `
            }

            getBatteryInfo() {
                if ('getBattery' in navigator) {
                    return 'API Available (checking...)'
                }
                return 'Not Available'
            }

            isWebGLAvailable() {
                const canvas = document.createElement('canvas')
                const gl = canvas.getContext('webgl') || canvas.getContext('webgl2')
                return gl !== null
            }

            parseUserAgent() {
                const ua = navigator.userAgent.toLowerCase()
                return {
                    architecture: ua.includes('x86_64') || ua.includes('amd64') ? 'x86_64' : 
                                ua.includes('arm64') || ua.includes('aarch64') ? 'ARM64' : 'Unknown',
                    platformType: ua.includes('iphone') || ua.includes('ipad') ? 'iOS' :
                                 ua.includes('android') ? 'Android' :
                                 ua.includes('mac') ? 'macOS' :
                                 ua.includes('windows') ? 'Windows' :
                                 ua.includes('linux') ? 'Linux' : 'Unknown',
                    isMobile: /mobile|android|iphone|ipad|phone/i.test(ua)
                }
            }

            isHighPerformanceDevice() {
                const cores = navigator.hardwareConcurrency || 0
                const memory = navigator.deviceMemory || 0
                const connection = navigator.connection?.effectiveType || ''
                
                return cores >= 8 || memory >= 8 || connection === '4g'
            }

            getMemoryUsage() {
                if (performance.memory) {
                    const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024)
                    const total = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    return `${used}MB / ${total}MB`
                }
                return 'Unknown'
            }

            // Cache management methods
            async getCacheStats() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to access cache', 'error')
                    return
                }

                this.showStatus('Getting cache stats...', 'info')
                
                try {
                    const response = await this.sendMessage('get-cache-stats')
                    if (response.success) {
                        const stats = response.stats
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cache Statistics</h3>
                            <p><strong>Total Size:</strong> ${this.formatBytes(stats.totalSize || 0)}</p>
                            <p><strong>Model Count:</strong> ${stats.modelCount || 0}</p>
                            <p><strong>Available Space:</strong> ${this.formatBytes(stats.availableSpace || 0)}</p>
                            <p><strong>Usage:</strong> ${Math.round(((stats.totalSize || 0) / (5 * 1024 * 1024)) * 100)}%</p>
                        `
                    } else {
                        this.showStatus(`Failed to get cache stats: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error getting cache stats: ${error.message}`, 'error')
                }
            }

            async getCachedModels() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to access cache', 'error')
                    return
                }

                this.showStatus('Getting cached models...', 'info')
                
                try {
                    const response = await this.sendMessage('get-cached-models')
                    if (response.success) {
                        const models = response.models || []
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cached Models</h3>
                            ${models.length > 0 ? models.map(model => `
                                <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                                    <p><strong>${model.name || model.id}</strong></p>
                                    <p>Size: ${this.formatBytes(model.size || 0)}</p>
                                    <p>Provider: ${model.provider || 'Unknown'}</p>
                                    <p>Cached: ${model.timestamp ? new Date(model.timestamp).toLocaleString() : 'Unknown'}</p>
                                </div>
                            `).join('') : '<p>No cached models found.</p>'}
                        `
                    } else {
                        this.showStatus(`Failed to get cached models: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error getting cached models: ${error.message}`, 'error')
                }
            }

            async clearAllCache() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to access cache', 'error')
                    return
                }

                this.showStatus('Clearing all cache...', 'info')
                
                try {
                    const response = await this.sendMessage('clear-all-cached-models')
                    if (response.success) {
                        this.showStatus('All cached models cleared successfully!', 'success')
                        
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cache Cleared</h3>
                            <p>All cached models have been removed.</p>
                        `
                    } else {
                        this.showStatus(`Failed to clear cache: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error clearing cache: ${error.message}`, 'error')
                }
            }

            async cleanupOldCache() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to access cache', 'error')
                    return
                }

                this.showStatus('Cleaning up old models...', 'info')
                
                try {
                    const response = await this.sendMessage('cleanup-old-cached-models', { maxAge: 7 * 24 * 60 * 60 * 1000 }) // 7 days
                    if (response.success) {
                        this.showStatus(`Old models cleaned up successfully! Removed ${response.removedCount || 0} models.`, 'success')
                        
                        const cacheInfo = document.getElementById('cacheInfo')
                        cacheInfo.style.display = 'block'
                        cacheInfo.className = 'status success'
                        cacheInfo.innerHTML = `
                            <h3>Cleanup Complete</h3>
                            <p>Old cached models have been removed. Removed ${response.removedCount || 0} models.</p>
                        `
                    } else {
                        this.showStatus(`Failed to cleanup old models: ${response.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error cleaning up old models: ${error.message}`, 'error')
                }
            }

            async loadDetailedDeviceInfo(devices) {
                const deviceDetails = document.getElementById('deviceDetails')
                deviceDetails.innerHTML = ''

                if (!devices || devices.length === 0) {
                    deviceDetails.innerHTML = '<p>No devices detected</p>'
                    return
                }

                devices.forEach((device, index) => {
                    const card = document.createElement('div')
                    card.className = 'provider-card'
                    
                    const performanceBar = this.createPerformanceBar(device.performance || 0)
                    const deviceTypeColor = this.getDeviceTypeColor(device.type)
                    
                    card.innerHTML = `
                        <h3 style="color: ${deviceTypeColor};">${device.name}</h3>
                        <p><strong>Type:</strong> ${device.type.toUpperCase()}</p>
                        <p><strong>Supported:</strong> ${device.supported ? '✅ Yes' : '❌ No'}</p>
                        <p><strong>Performance Score:</strong> ${device.performance || 0}/100</p>
                        <div style="margin: 10px 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span>Performance</span>
                                <span>${device.performance || 0}%</span>
                            </div>
                            ${performanceBar}
                        </div>
                        <button onclick="window.testPage.testDeviceCapabilities('${device.name}')" style="margin-top: 10px;">
                            Test Capabilities
                        </button>
                    `
                    deviceDetails.appendChild(card)
                })
            }

            createPerformanceBar(performance) {
                const percentage = Math.min(performance, 100)
                const color = performance >= 80 ? '#28a745' : performance >= 60 ? '#ffc107' : '#dc3545'
                
                return `
                    <div style="width: 100%; height: 8px; background-color: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${percentage}%; height: 100%; background-color: ${color}; transition: width 0.3s ease;"></div>
                    </div>
                `
            }

            getDeviceTypeColor(type) {
                const colors = {
                    npu: '#007bff',
                    gpu: '#28a745',
                    cpu: '#ffc107'
                }
                return colors[type] || '#6c757d'
            }

            async refreshWebNNDevices() {
                if (!this.extensionAvailable) {
                    this.showStatus('Extension required to refresh WebNN devices', 'error')
                    return
                }

                this.showStatus('Refreshing WebNN devices...', 'info')
                
                try {
                    const devicesResponse = await this.sendMessage('get-webnn-devices')
                    if (devicesResponse.success) {
                        const devices = devicesResponse.devices || []
                        this.loadDetailedDeviceInfo(devices)
                        
                        // Update the device count
                        const webnnDeviceCount = document.getElementById('webnnDeviceCount')
                        webnnDeviceCount.textContent = devices.length
                        
                        this.showStatus(`Refreshed WebNN devices. Found ${devices.length} devices.`, 'success')
                    } else {
                        this.showStatus(`Failed to refresh devices: ${devicesResponse.error}`, 'error')
                    }
                } catch (error) {
                    this.showStatus(`Error refreshing devices: ${error.message}`, 'error')
                }
            }

            async testDeviceCapabilities(deviceName) {
                this.showStatus(`Testing capabilities for device: ${deviceName}...`, 'info')
                
                try {
                    // This would call a method to test device capabilities
                    // For now, we'll simulate the test
                    setTimeout(() => {
                        this.showStatus(`Device capabilities test completed for ${deviceName}`, 'success')
                    }, 1000)
                } catch (error) {
                    this.showStatus(`Error testing device capabilities: ${error.message}`, 'error')
                }
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes'
                
                const k = 1024
                const sizes = ['Bytes', 'KB', 'MB', 'GB']
                const i = Math.floor(Math.log(bytes) / Math.log(k))
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
            }
        }

        // Initialize the test page
        window.testPage = new ONNXTestPage()
    </script>
</body>
</html> 